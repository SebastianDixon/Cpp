Inheritance


new classes can be derived from existing ones using inheritance
```
class Meat
{
    private:
    double protein;
    double price;
    string animal;

    public:
    Meat();
    Meat(double protein, double price, string animal);
    ~Meat();
    void meatStats()
    {
        cout << protein << price << animal << endl;
    }
};

class Steak: Meat
{
    private:
    enum cooked {rare=1, mediumrare, medium, welldone};
    string animal = "Cow";

    public:
    Steak();
    Steak(double protein, double price, enum cooked);
    ~Steak();
};
```

the class meat has been made which private variables protein, price and animal. 
These variables have been inherited by the class Steak, and subclass of the base class meat.

the class Steak has added onto the meat class its own private variables and can assign the values of the aforementioned variable animal

the privateÂ  variables in the base class cant be accessed by an inherited class

protected variables are also present in classes

Protected keyword


a protected variable allows the scope of the variable to change. the variable is pubic to inheritance classes, but private outside of its own class and the inherited classes

this does away with the necessity of creating accessing functions for the inherited classes to use the base class variables

using an accessor function in the instance of a protected variable doesn't produce an error, but just overrides the action

```
protected:
    double protein;
    double price;
    string animal;
```
this is how it is implemented in the base class

Friend functions


this can be created by a class to form an external function which can access all the members of the class
to use these members they must be passed as arguments as they cannot take the this keyword

Virtual functions


the virtual keyword is used to preface the initialisation of a virtual function
i have defined the name and the type of function inside the public member of the class I wish to inherit from

```
class Person
{
    private:
    string name;
    int age;

    public:
    virtual void displayProp() const;

};

void Person::displayProp() const
{
    cout << name << '\n' << age << endl;
}
```
the function displayProp() was overridden by the definition outside of the class declaration. it was able to inherit the private attributes from the Person class and was given const definition.

if another class is created as a subclass of the initial class which declared the virtual function. the subclass can create its own same virtual function with the newly added variables
here i have made a subclass of the person class called student. this includes the private member college. as i would also like to output this with the function displayProp() i need to overwrite the previous definition of this virtual function as such

```
class Student:public Person
{
    private:
    string college;

    public:
    virtual void displayProp() const;
    
};

void Student::displayProp() const
{
    Person::displayProp();
    cout << college << endl;
}
```
the exact same virtual function declaration is made in the class public member. upon later overwriting this initialisation we use the Student:: identifier
in order to use the same funcitonality from the parent class virtual function, Person::displayProp() has been called to output the parent class private members

Virtual destructors


if a base class defines one or more virtual functions, they should also include virtual destructors
by defining a virtual destructor in the base class it is then always known which destructor is being called

```
class Person
{
    protected:
    string name;
    int age;

    public:
    virtual ~Person();

};
```
the later overwritten person destructor
```
Person::~Person()
{
    cout << "Person object deleted" << endl;
}
```

The principle of substitutability


a pointer of type X can be allocated to the variable of type X 
a reference of type X can be allocated to the variable of type X

e.g.
Person * p1 = new Person;
Person * p2 = new Student;

Person & r1 = somePersonObject;
Person & r2 = someStudentObject;

```
Person * p1 = new Student{"Pointer", "Bill", 70};
   
p1->displayProp();
```
- I have created a dynamic object with a pointer called p1
- the Person class has a subclass of Student
- Both base and sub class have the virtual function displayProp()
- the p1 pointer calls the function displayProp using the arrow selection
- given both classes feature that same named virtual function the compiler makes a process of decisions
	- it finds that the base class uses the function
	- it sees that the pointer is allocated to an object under the Student subclass
	- it finds the virtual function in the subclass
- this process of determining the virtual function is done upon runtime

this process of overriding the virtual function from the base class can only occur given that the displayProp() function is virtual
this is known as polymorphism

this is taking advantage of the intelligence of the system to instead look at the object type of the clarification, rather than the pointer type when given a virtual function


Invoking virtual functions


when using a pointer, the arrow operator is used to invoke the virtual function e.g.
p1->display()

when using a reference, the dot notation is used to invoke the virtual function e.g.
r1.display()

if the object is created in the virtual function, the virtual destructor will be called to delete the object
and visa versa

Pure virtual functions


a pure virtual function is one which isn't instantiated in the base class and must be overwritten in the sub class
to declare a pure virtual function they are assigned a value of 0 in the declaration
```
virtual string displayNew() = 0;
```

this shows the assignment of a pure virtual function which returns string type

when a pure virtual function is implemented in the base class it is an abstract class