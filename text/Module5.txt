Pointers


each variable being declared has a memory location, then referred to as the variable, this memory location is fixed throughout the use of the program, and is referred to as the scope of the variable

most objects in c++ have an identity which means they have a unique memory location during their lifetime

A pointer is a variable that holds the memory address of these objects or variable that have been declared.
to use pointers, declare a pointer variable

initialisation of a pointer variable
```
int num = 3;
int* pNum = &num;
```

the variable 'num' has the value of 3, this is stored under a memory address
initialising the variable 'pNum' is the pointer variable, it has integer form as indicated by the int with *
the value stored is &num, this is the memory address of variable num, as inidicated by the & character

this address looks like 0x61ff08

the original value stored under that address can be found placing a * before the variable name storing the address:
```
int val = *pNum;
```

running the program again, will give the address a different value, as it is only specific to that run

leaving a pointer uninitialized is not recommended as it can produce bugs difficult to track and leaves your code unsecure

Reference types


- A reference type is an alias for another type
- the reference type overloads the use of the & operator
- A reference cannot be reassigned later in the code
- A reference must be assigned a value upon creation to prevent error

Upon initialisation of the reference type, the operator must be shown at the instance
```
int num2 = 3;
int & refNum = num2;    //reference declred with & operator
refNum = 4;

cout << num2 << endl;
cout << refNum << endl;
cout << &num2 << '\n' << &refNum << endl;
```
- the integer num2 with a value of 3 is made
- the reference 'refNum' is made and assigned to the integer num2
- refNum is reassigned to the integer value 4
- this also changes the value of num2 to 4

both the integer and assigned reference have the same address in memory

a common usage in C++ is for references to be made in parameters for functions, this can assign the parameter value to the variable where it was called
```
void passByRef(int &);  //function prototype shown to be given a reference argument in its parameters

int main()
{
    int num = 3;
    cout << "num starts as: " << num << endl;
    passByRef(num);
    cout << "num value referenced after function increment: " << num << endl;
    
    return num;
}

void passByRef(int & refNum)
{
    cout << "reference value passed as: " << refNum << endl;
    ++refNum;
    cout << "reference value incremented: " << refNum << endl;
}
```

the function 'passByRef' is made with the arguments as a reference integer
inside the main function an integer num is created with value 3

this is passed to the function passByRef, then the reference argument given in the parameter is assigned to the integer variable num
the value of refNum is incremented by 1, this applied the same operation to the num value as they are stored at the same address

Memory management


A memory leak can occur if instantiated objects arent finished and released from memory when the program is finished.
More and more memory is requested from the limited quantity to instantiate more objects.
When too much memory is requested, the OS will commonly stop the program at this point

Allocating memory


different keywords are used to determine memory properties for variables being created

Pointers can be assigned to data types, instead of variables
This is done at the start of the program. this tells the compiler that when the program runs to dynamically assign some memory to hold the data type value

by the process of dereferencing is used to then assign a value to the address created
```
int * pInt = new int;
double * pDouble = new double;

*pInt = 3;
*pDouble = 5.0;
```


here a pointer is made to both int and double data types
the address of these values is unknown, by dereferencing, the values of 3 and 5.0 are assigned, and these new memory addressing are dynamically assigned to these values

The new operator is an operator which denotes a request for memory allocation on the Heap.

the size of the address at both pInt and pDouble is 4 bytes, however the size of the variable stored at these address may differ from this size of the address
for our example here, the size of the values stored at these respective addresses is 4 and 8 bytes.

Deallocating memory


If unused memory is not released to the operating system, it is wasted, and will ultimately create a memory leak is more memory is allocated dynamically by the program
the keyword delete is used to release the memory back to the OS
```
int * pInt = new int;
double * pDouble = new double;

*pInt = 3;
*pDouble = 4.2;

delete pInt;
delete pDouble;
```

Headers


a class file allows you to model real world application in your code

the #include pre-processor directive is used to implement the header file
in c++ it is common practice to split your classes into two files, the function file, ending in .h, and the implementation of that code in the other, .cpp file

e.g. creating a function to perform a mathematical operation such as exponent
producing a header file which contains the mathematical operation as such will be good practice

```
#pragma once
// math.h
using namespace std;

void Pow(int base, int power)
{
    int output = base;
    for(int count = power -1; count > 0; --count)
    {
        output *= base;
        cout << output << endl;
    }
    cout << "Answer is: " << output << endl;
}
```

```
#include "math.h"
// main.cpp
using namespace std;

int main()
{
    Pow(4,5);
    
    return 0;
}
```
the .cpp file used the include statement and was able to use the function defined in the header file

a static class can be defined in the header, the static keyword would allow the class to be used without having to have made an instantiation of it before hand

Dynamic object creation


the instance of a class can be created using pointers, these are initialised as such:

```
Person * p3 = new Person("Rick", "Gervais", 50);

p3->get_iD();
```

in order to perform operation on these pointers the arrow selection statement is used instead of the dot selection

```
delete p3;
```

then delete the pointer after use to prevent a system memory leak

Class scope
