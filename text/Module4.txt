functions


functions are defined with a name, parameters and or a return type and the final body of code, the return statement is optional like python. the arguments passed in the functions definition may or may not be passed

overloading a function refers the referencing multiple functions under the same name, for the sake of increased functionality, this is a more advanced feature though
multiple functions may be defined under the same name, but have different arguments passed to them, therefore it is the job of the compiler to determine which parameters were passed to call the function, and accordingly choose which of the functions to return

e.g. this example
```
int sum(int x, int y) //first sum function 
{ 
    int val; 
    val = x + y; 
    cout << val << endl; 
    return x + y; 
} 
int sum(int x, int y, int z) //second sum function 
{ 
    return x + y + z; 
} 
int main() 
{ 
    return sum(3, 4); 
}

```

here the first sum function is called given it contains two arguments, and the main functions calls a sum function will two parameters
if the return statement were to contain three integer parameters, the second would be called

the functions storage class, return type, name, parameters are called it function prototype
this function definition exists in the source code

inline functions


you preface the creation of an inline function by using the 'inline' keyword
an inline functions is more efficient in the code, this is because it is more memory efficient, and does away with the typical calling of a function

```
inline void swap(int i, int j)
{
    int temp = i;
    i = j;
    j = temp;
}
int main()
{
    swap(3, 4);
    return 0;
}
```

here the inline function 'swap' has been made with initialised variables 'i' and 'j'

the calling of this function in the main function is where the compiler simply places the code from the inline function using the arguments given

- the compiler may ignore your request for the inline function and call it normally
- use inline functions for small pieces of code, not huge operations

storage classes and scope


when a variable goes out of scope, its memory is released back into the operating system for use

linkage is a term to describe the reach of variable outside the file where it is initialised

the scope of a variable is where it is able to be used 


C++ makes use of the following keywords that apply to storage classes:

- static - identifiers declared with static are allocated when the program starts and deallocated when the program execution ends.  Declaring a variable as static in a function means that the variable will retain its value between calls to the function.
- extern - used to declare an object that is defined in another translation unit of within the enclosing scope but has an external linkage.
- thread_local - declares that the identifier is only accessible on the thread in which it is created.  This prevents sharing of the identifier across multiple threads in the same application.   This is part of the C++11 standard.

objects (classes)


name your classes with a capital letter

the class is a reusable blueprint for an object being instanced in your code
useful for something which has different properties values for each instance of it, but has the same fundamental property types

e.g. a character would have a name, health, damage, defence
	all of these attributes would be different for each character, and they all have these base attributes
	
classes can define variables differently depending on the scope you wish them to have in the program.
the 'public' modifier makes the variable both readable and writable outside the class

```
class player 
{ 
public: 
    string name; 
    int health; 
    int damage; 
    void print() 
    { 
        cout << name << " " << health<< " " << damage<< " " << '\n' << endl; 
    } 

    void calc(int i, int j) 
    { 
        auto result {i + j}; 
        cout << result << endl; 
    }

};

```

here a class 'player' has been made, it can be seen that it has public attributes name, health and damage of different data types
an instance of the this class has been made called 'instance' 

the use of the 'void' keyword indicates nothing is being returned

the function 'print' is known as a member function or a method
the function 'calc' uses arguments which can be defined later on to produce an output

```
int main()
{
    player p1;
    player p2;

    p1.name = "Fred";
    p2.name = "Bob";

    p1.health = 100;
    p2.health = 80;

    p1.damage = 5;
    p2.damage = 9;
    
    player p3 {"Seb", 50, 100};
    p1.print();
    p2.print();
    p3.print();
    
    return 0;
}
```
instances of a class can be made in different ways, such as the uniform notation used for the instance 'p3'

within 'instance' two instances of the player class are made, named 'Fred' and 'Bob'
using the dot notation, each of the variables in the player class can be assigned to these individual instances

variables of a class are different, they can be private or public, they are by defauly private, and require the keyword public otherwise
Private members are members of a class that can only be accessed by other members of the class
Public members are members of a class that can be accessed by anyone

```
class Account
{   
    private:
        int balance{};
        int debt{};
    public:
        string username;
};
```

Encapsulation


this is an example of encapsulation
```
class Base
{
int x;

public:
    void getA(int a) {a = x;}
    int getX() {return x;}
}
```

the data and functions are stored under the class name 'Base'

the class is an example of encapsulation, if we have created a class with a data member, and member function

Const objects


both variables and objects can be constant, this would be declared upon the initialisation of the class
the object is then called 'immutable' this means it cant be changed

```
Player mutant{"ogre", 200, 2};
Player const immutant{"boss", 1000, 10};
```
this shows the use of the const keyword in the initialisation of an object

member functions may also be defined using the const keyword, this tells the compiler that this member function does not change the values of the const object we created, and so it can be used

```
int get_area() const
    {
        return width * height;
    }

```
this shows the const keyword in use on a member function

a const object can only use const member functions
thats why when a member function is made, which isnt changing the parameters of an object, the const keyword should be stated
